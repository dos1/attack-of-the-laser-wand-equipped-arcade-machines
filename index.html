<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Attack of the Laser Wand Equipped Arcade Machines</title>
    <script src="aframe.min.js"></script>
<script src="aframe-gif-shader.min.js"></script>
    <script src="alleg.js"></script>
    <script src="logo.js"></script>
    <script src="jquery-3.2.1.min.js"></script>

  
<script id="2d-vertex-shader" type="x-shader/x-vertex">// <![CDATA[
precision highp float;
precision highp int;
attribute vec2 a_position;
  void main() {
    gl_Position = vec4(a_position, 0, 1);
  }
// ]]></script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">// <![CDATA[
precision highp float;
precision highp int;
//
// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER
//
//   by Timothy Lottes
//
// This is more along the style of a really good CGA arcade monitor.
// With RGB inputs instead of NTSC.
// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.
//
// Left it unoptimized to show the theory behind the algorithm.
//
// It is an example what I personally would want as a display option for pixel art games.
// Please take and use, change, or whatever.
//
uniform sampler2D tex;
// Emulated input resolution.
#if 1
  // Fix resolution to set amount.
  #define res (vec2(640.0/1.0,360.0/1.0))
#else
  // Optimize for resize.
  #define res (iResolution.xy/6.0)
#endif

// Hardness of scanline.
//  -8.0 = soft
// -16.0 = medium
float hardScan=-8.0;

// Hardness of pixels in scanline.
// -2.0 = soft
// -4.0 = hard
float hardPix=-3.0;

// Display warp.
// 0.0 = none
// 1.0/8.0 = extreme
vec2 warp=vec2(1.0/24.0,1.0/16.0); 

// Amount of shadow mask.
float maskDark=0.5;
float maskLight=1.5;

//------------------------------------------------------------------------

// sRGB to Linear.
// Assuing using sRGB typed textures this should not be needed.
float ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}
vec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}

// Linear to sRGB.
// Assuing using sRGB typed textures this should not be needed.
float ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}
vec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}

// Nearest emulated sample given floating point position and texel offset.
// Also zero's off screen.
vec3 Fetch(vec2 pos,vec2 off){
  pos=floor(pos*res+off)/res;
  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);
  pos.y = 1.0-pos.y;
  return ToLinear(texture2D(tex,pos.xy,-16.0).rgb);}

// Distance in emulated pixels to nearest texel.
vec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}
    
// 1D Gaussian.
float Gaus(float pos,float scale){return exp2(scale*pos*pos);}

// 3-tap Gaussian filter along horz line.
vec3 Horz3(vec2 pos,float off){
  vec3 b=Fetch(pos,vec2(-1.0,off));
  vec3 c=Fetch(pos,vec2( 0.0,off));
  vec3 d=Fetch(pos,vec2( 1.0,off));
  float dst=Dist(pos).x;
  // Convert distance to weight.
  float scale=hardPix;
  float wb=Gaus(dst-1.0,scale);
  float wc=Gaus(dst+0.0,scale);
  float wd=Gaus(dst+1.0,scale);
  // Return filtered sample.
  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}

// 5-tap Gaussian filter along horz line.
vec3 Horz5(vec2 pos,float off){
  vec3 a=Fetch(pos,vec2(-2.0,off));
  vec3 b=Fetch(pos,vec2(-1.0,off));
  vec3 c=Fetch(pos,vec2( 0.0,off));
  vec3 d=Fetch(pos,vec2( 1.0,off));
  vec3 e=Fetch(pos,vec2( 2.0,off));
  float dst=Dist(pos).x;
  // Convert distance to weight.
  float scale=hardPix;
  float wa=Gaus(dst-2.0,scale);
  float wb=Gaus(dst-1.0,scale);
  float wc=Gaus(dst+0.0,scale);
  float wd=Gaus(dst+1.0,scale);
  float we=Gaus(dst+2.0,scale);
  // Return filtered sample.
  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}

// Return scanline weight.
float Scan(vec2 pos,float off){
  float dst=Dist(pos).y;
  return Gaus(dst+off,hardScan);}

// Allow nearest three lines to effect pixel.
vec3 Tri(vec2 pos){
  vec3 a=Horz3(pos,-1.0);
  vec3 b=Horz5(pos, 0.0);
  vec3 c=Horz3(pos, 1.0);
  float wa=Scan(pos,-1.0);
  float wb=Scan(pos, 0.0);
  float wc=Scan(pos, 1.0);
  return a*wa+b*wb+c*wc;}

// Distortion of scanlines, and end of screen alpha.
vec2 Warp(vec2 pos){
  pos=pos*2.0-1.0;    
  pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);
  return pos*0.5+0.5;}

// Shadow mask.
vec3 Mask(vec2 pos){
  pos.x+=pos.y*3.0;
  vec3 mask=vec3(maskDark,maskDark,maskDark);
  pos.x=fract(pos.x/6.0);
  if(pos.x<0.333)mask.r=maskLight;
  else if(pos.x<0.666)mask.g=maskLight;
  else mask.b=maskLight;
  return mask;}    

// Draw dividing bars.
float Bar(float pos,float bar){pos-=bar;return pos*pos<4.0?0.0:1.0;}

// Entry.
void main(){
  // Unmodified.
  vec4 fragColor;
  vec4 fragCoord = gl_FragCoord;
  
  vec2 iResolution = res;
  
  if(false && fragCoord.x<iResolution.x*0.333){
    fragColor.rgb=Fetch(fragCoord.xy/iResolution.xy,vec2(0.0,0.0));}
  else{
    vec2 pos=Warp(fragCoord.xy/iResolution.xy);
    if(false && fragCoord.x<iResolution.x*0.666){
      hardScan=-12.0;
      maskDark=maskLight=1.0;
      pos=Warp(fragCoord.xy/iResolution.xy);}
    fragColor.rgb=Tri(pos)*Mask(fragCoord.xy);}    
  fragColor.a=1.0;  
//  fragColor.rgb*=
  //  Bar(fragCoord.x,iResolution.x*0.333)*
    //Bar(fragCoord.x,iResolution.x*0.666);
  fragColor.rgb=ToSrgb(fragColor.rgb);
  gl_FragColor = fragColor;
  }
// ]]></script>
  
    <script>
    
    cameraPos = {x:0, y:0, z:0 };
    cameraDiff = new THREE.Vector3(0,0,0);
    
    gameHasStarted = false;
          gameHasSetup = false;

    AFRAME.registerComponent('trigger-listener', {
  init: function () {
    var el = this.el;
//    $('#dos')[0].setAttribute('visible', true);
    el.addEventListener('triggerdown', function (evt) {
      el.setAttribute('line', "color: red; opacity: 1");
      console.log('down');
    });
    el.addEventListener('triggerup', function (evt) {
      el.setAttribute('line', "color: yellow; opacity: 0.3");
      console.log('up'); //, $(el).find('*'));
    });
  }
});


AFRAME.registerComponent('mouse-listener', {
  init: function () {
    var el = this.el;
//    $('#dos')[0].setAttribute('visible', true);
    el.addEventListener('mouseenter', function (evt) {
     // el.setAttribute('line', "color: red; opacity: 1");
      console.log('enter');
    });
    
        el.addEventListener('mousedown', function (evt) {
     // el.setAttribute('line', "color: red; opacity: 1");
     if (gameHasStarted) {
     
/*      (function() {
      var expl = $('<a-plane width="2" height="1" material="shader: gif; src:url(explosion.gif);transparent: true; side: double"></a-plane>').appendTo('a-scene');
      expl.attr('position', el.getAttribute('position').split(' ')[0] + " 0.5 " + el.getAttribute('position').split(' ')[2]);
      expl.attr('rotation', el.getAttribute('rotation'));
      
      setTimeout(function() { expl.remove(); }, 2000);
})();
*/
     
      el.parentNode.removeChild(el);
      } else {
      gameHasStarted = true;
      gameHasSetup = false;
/*
      (function() {
      var expl = $('<a-plane width="2" height="1" material="shader: gif; src:url(explosion.gif);transparent: true; side: double"></a-plane>').appendTo('a-scene');
      expl.attr('position', el.getAttribute('position').split(' ')[0] + " 0.5 " + el.getAttribute('position').split(' ')[2]);
      expl.attr('rotation', el.getAttribute('rotation'));
      
      setTimeout(function() { expl.remove(); }, 2000);
})();
*/      
      el.setAttribute('position', '99999 -99999 99999');
      }
    });
    
    el.addEventListener('mouseleave', function (evt) {
      //el.setAttribute('line', "color: yellow; opacity: 0.3");
      console.log('leave'); //, $(el).find('*'));
    });
  }
});
    
    	AFRAME.registerComponent("camera-listener", {
		schema : 
		{},
		tick : function()
		{	
		var newcameraPos = this.el.components.camera.camera.parent.position;
		var rot = this.el.components.camera.camera.parent.rotation;
		
		var testpos = new THREE.Vector3(newcameraPos.x, newcameraPos.y, newcameraPos.z).sub(new THREE.Vector3(cameraPos.x, cameraPos.y, cameraPos.z));
		var difference = new THREE.Vector3(testpos.x, testpos.y, testpos.z);
		testpos = testpos.applyAxisAngle(new THREE.Vector3(1,0,0), rot.x);
		testpos = testpos.applyAxisAngle(new THREE.Vector3(0,1,0), -rot.y);
		testpos = testpos.applyAxisAngle(new THREE.Vector3(0,0,1), rot.z);
		
		// xyz xzy yxz yzx zxy zyx
		//if (difference.z < -0.01) {  
//		if (testpos.z < -0.01) {
//		difference.x = -difference.x;
		if (testpos.z < -0.001) {
		  console.log(testpos);
		//difference.x = -difference.x;
difference.y = 0;
                    cameraDiff.add(difference.multiplyScalar(3));
            }
  //              }
		//console.log(difference);
		//}

		
//		if (cameraPos.z != newcameraPos.z) {
//		   console.log(cameraPos.z - newcameraPos.z);
//		}
                        cameraPos = {x:newcameraPos.x, y:newcameraPos.y, z:newcameraPos.z};
		}
	});
</script>
  </head>
  <body>
    <a-scene>
      <a-assets>
        <canvas id="logo_canvas" width="320" height="180"></canvas>
        <canvas id="glcanvas" width="320" height="180"></canvas>
        <video id="discovr" src="bg2.mp4" loop autoplay />
        <img id="frame" src="frame.png" />
        <img id="wood" src="wood.jpg" />
        <img id="dosowisko" src="dosowisko.png" />
        <img id="buttons" src="buttons.png" />
        <img id="hp" src="100hp.png" />
        <img id="coiner" src="coiner.png" />
        <img id="explosion" src="explosion.gif" />
      </a-assets>
<!--      <a-box shadow="cast:true;receive:true;" position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
      <a-sphere shadow="cast:true;receive:true;" position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
      <a-cylinder shadow="cast:true;receive:true;" position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
      <a-plane shadow="cast:true;receive:true;" position="0 0.1 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>


      <a-box shadow="cast:true;receive:true;" position="0 1 -2" scale="0.7 0.7 0.7" color="#4CC3D9" src="#discovr"></a-box>
-->

      <a-entity position="0 9 -1.5" class="arcade collidable" id="arcade-template" mouse-listener>
        <a-entity position="0 0.6 0">
            <a-box position="0 0 0" width="1" height="1.2" depth="0.75" color="gray" shadow="cast:true;receive:true;"></a-box> 

            <a-box position="0 0.675 0.05" width="1" height="0.15" depth="0.85" color="gray" shadow="cast:true;receive:true;"></a-box> 

            <a-plane position="0 0.751 0.3" rotation="-90 0 0" material="transparent: true; side: double" width="0.8" height="0.325" src="#buttons" shadow="cast:false;receive:true;"></a-plane>         
            
            <a-box position="0 1.0625 -0.125" width="1" height="0.625" depth="0.5" color="gray" shadow="cast:true;receive:true;"></a-box> 

            <a-plane position="0 1.0625 0.126" width="1" height="0.625" src="#glcanvas" shadow="cast:false;receive:false;"></a-plane> 

            <a-box position="-0.45 1.0625 0.25" width="0.1" height="0.625" depth="0.25" color="gray" shadow="cast:true;receive:true;"></a-box> 
            <a-box position="0.45 1.0625 0.25" width="0.1" height="0.625" depth="0.25" color="gray" shadow="cast:true;receive:true;"></a-box> 
            <a-box position="0 1.5625 0.025" width="1" height="0.375" depth="0.8" color="gray" shadow="cast:true;receive:true;"></a-box> 

            <a-plane position="0 1.5625 0.426" width="0.95" height="0.325" id="dos" src="#dosowisko" shadow="cast:false;receive:true;"></a-plane> 

            <a-plane position="0.375 0.35 0.4" width="0.025" height="0.1" src="#coiner" class="collidable" shadow="cast:false;receive:true;" ></a-plane> 
    
        </a-entity>

      </a-entity>

      <a-plane position="0 2.5 -25" material="transparent: true; side: double" src="frame.png" repeat="10 1" rotation="0 0 0" width="50" height="5"></a-plane>
      <a-plane position="0 2.5 25" material="transparent: true; side: double" src="frame.png" repeat="10 1" width="50" height="5"></a-plane>
      <a-plane position="25 2.5 0" rotation="0 -90 0" material="transparent: true; side: double" src="frame.png" repeat="10 1" width="50" height="5"></a-plane>
      <a-plane position="-25 2.5 0" rotation="0 -90 0" material="transparent: true; side: double" src="frame.png" repeat="10 1" width="50" height="5"></a-plane>
      
      
      <a-box shadow="receive:true;" position="0 -0.5 0" rotation="-90 0 0" width="50" height="50" src="#wood"></a-box>

      <a-box position="0 -501 0" rotation="0 0 0" width="10" height="1000" depth="10" src="#wood"></a-box>

      
      
      
      <a-videosphere position="0 25 0" src="#discovr" radius="100" loop webkit-playsinline autoplay></a-videosphere>

      <a-entity position="0 0 0" rotation="0 0 0" class="position">
        <a-entity position="0 0 0" rotation="0 0 0" class="screenshake">
            <a-entity id="camera" camera-listener camera="userHeight: 1.6" look-controls wasd-controls></a-entity>
        </a-entity>
      <a-entity id="laser" laser-controls="hand: right" raycaster="far: 6" trigger-listener></a-entity>
      </a-entity>

    </a-scene>
    
<script>
var vr=false;
document.querySelector('a-scene').addEventListener('enter-vr', function () {
//        $('.screenshake').attr('position', '0 0 0');
        vr=true;
});

document.querySelector('a-scene').addEventListener('loaded', function () {

//console.log(cameraPos);

var shake;

function screenShake() {
    var shakeCount = 0;
    shake = setInterval(function() {
        $('.screenshake').attr('position', Math.random()/8.0 + ' ' + Math.random()/8.0 + ' ' + Math.random()/8.0);
        shakeCount++;
        if (shakeCount > 42) {
        $('.screenshake').attr('position', '0 0 0');
            clearInterval(shake);
        }
    }, 10);
}

//setTimeout(screenShake, 3000);

var start = Date.now(), oldt = start, touched = false;

var speechEnabled = false;

var gameStarted = false;

function frame() {
  var t = Date.now(); 
  if (!speechEnabled && !gameHasStarted) {
$('#arcade-template').attr('position', '0 ' + Math.max(0, 5*(9-((t-start)/1000)*3)) + ' -1.5');
}
  if (!touched) {
var val =  (10*(9-((t-start)/1000)*3)/90);
      $('.screenshake').attr('rotation', Math.max(0, (val>0.0001) ? Math.sqrt(val,2) : 0 ) * 90 +' 0 0');

  
    if (t-start >= 3000) {
      screenShake();
      touched = true;
    }
  } else {
    
    if (!speechEnabled) {
        var time = (t-start)/1000 - 3;
    
        $('.position').attr('position', '0 0 -' + Math.min(1, Math.pow(time/3, 2))*0.8);
        
        if (t-start >= 9000) {
            // enable speech
            /*
            var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition
var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList
var SpeechRecognitionEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent

var spells = [ 'insert coin', 'alohomora', 'alohamora', 'seicento', 'flipendo', 'rictusempra', 'onomatopoeia', 'leviosa', 'wingardium leviosa', 'lumos', 'spongify'];
var grammar = '#JSGF V1.0; grammar spells; public <spell> = ' + spells.join(' | ') + ' ;'

var recognition = new SpeechRecognition();
var speechRecognitionList = new SpeechGrammarList();
speechRecognitionList.addFromString(grammar, 1);
recognition.grammars = speechRecognitionList;
recognition.continuous = true;
recognition.lang = 'en-US';
recognition.interimResults = true;
recognition.maxAlternatives = 1;

  recognition.start();

recognition.onresult = function(event) {
  // The SpeechRecognitionEvent results property returns a SpeechRecognitionResultList object
  // The SpeechRecognitionResultList object contains SpeechRecognitionResult objects.
  // It has a getter so it can be accessed like an array
  // The [last] returns the SpeechRecognitionResult at the last position.
  // Each SpeechRecognitionResult object contains SpeechRecognitionAlternative objects that contain individual results.
  // These also have getters so they can be accessed like arrays.
  // The [0] returns the SpeechRecognitionAlternative at position 0.
  // We then return the transcript property of the SpeechRecognitionAlternative object

  var last = event.results.length - 1;
  var result = event.results[last][0].transcript;
  console.log(result, 'Confidence: ' + event.results[0][0].confidence);
  
  if (result.trim() == 'insert coin') {
    $('#arcade-template').attr('position', '9999 9999 9999');
    gameStarted = true;
  }
}

recognition.onspeechend = function() {
  recognition.stop();
}

recognition.onnomatch = function(event) {
  //diagnostic.textContent = "I didn't recognise that color.";
}

recognition.onerror = function(event) {
//  diagnostic.textContent = 'Error occurred in recognition: ' + event.error;
}
            */
            
            speechEnabled = true;
        }
    } 
//    console.log(cameraDiff);
if (vr) {
            $('.position').attr('position', cameraDiff.x + ' ' + cameraDiff.y + ' ' + cameraDiff.z);
}
        // speech enabled
        
    
  if (gameHasStarted) {
if (!gameHasSetup) {
  gameHasSetup = true;
    setInterval(function() {
        var clone = $('#arcade-template').clone();
        clone.attr('id', '');
        clone.attr('position', (Math.random()*20-10) + ' 0 ' + (Math.random()*20-10));
        clone.attr('rotation', '0 ' + Math.random()*360 + ' 0');
        clone.appendTo($('a-scene'));
        
       }, 2000);
  }
}  
  }
window.requestAnimationFrame(frame);
}

window.requestAnimationFrame(frame);


});
</script>

  </body>
</html>
